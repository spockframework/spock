buildscript {
  repositories {
    maven { url "http://dl.bintray.com/content/aalmiray/asciidoctor" }
    jcenter()
  }

  dependencies {
    classpath "org.asciidoctor:asciidoctor-gradle-plugin:1.5.2"
    classpath 'pl.allegro.tech.build:axion-release-plugin:1.3.3'
    classpath "io.codearte.gradle.nexus:gradle-nexus-staging-plugin:0.5.3"
  }
}

apply plugin: "base"
apply plugin: "org.asciidoctor.convert"
apply plugin: 'pl.allegro.tech.build.axion-release'
apply plugin: 'io.codearte.nexus-staging'

description = "Spock Framework"

ext {
  variants = [2.0, 2.3, 2.4]
  variant = System.getProperty("variant") as BigDecimal ?: variants.first()
  if (variant == 2.0) {
    groovyVersion = "2.0.8"
    minGroovyVersion = "2.0.0"
    maxGroovyVersion = "2.2.99"
  } else if (variant == 2.3) {
    groovyVersion = "2.3.11"
    minGroovyVersion = "2.3.0"
    maxGroovyVersion = "2.3.99"
  } else if (variant == 2.4) {
    groovyVersion = "2.4.5"
    minGroovyVersion = "2.4.0"
    maxGroovyVersion = "2.9.99"
  } else {
    throw new InvalidUserDataException("Unknown variant: $variant. Choose one of: $variants")
  }
  javaVersions = [1.7, 1.8]
  javaVersion = System.getProperty("java.specification.version") as BigDecimal
  targetJavaVersion = "1.6"
  releaseTriggeringCommand = "[#DO_RELEASE]"
  libs = [
    jetbrainsAnnotations: "org.jetbrains:annotations:13.0",
    ant: "org.apache.ant:ant:1.9.4",
    asm: "org.ow2.asm:asm:5.0.3",
    cglib: "cglib:cglib-nodep:3.2.0",
    groovy: "org.codehaus.groovy:groovy-all:$groovyVersion",
    h2database: "com.h2database:h2:1.3.174",
    junit: "junit:junit:4.12",
    log4j: "log4j:log4j:1.2.17",
    objenesis: "org.objenesis:objenesis:2.1"
  ]
}

scmVersion {
  tag {
    prefix = 'release'
    versionSeparator = '/'
  }
  createReleaseCommit = true
  releaseCommitMessage { version, position -> "Release version: ${version}\n\n[ci skip]" }
  versionIncrementer 'incrementPrerelease'
}

String calculateFullVersion(String baseVersion) {
  //TODO: Replace with a smart regexp like (.*)(-SNAPSHOT|) -> {1}-groovy-2.3{2}
  if (baseVersion.endsWith('-SNAPSHOT')) {
    return baseVersion - '-SNAPSHOT' + "-groovy-$variant-SNAPSHOT"
  }
  return baseVersion + "-groovy-$variant"
}

ext {
  baseVersion = scmVersion.version
  fullVersion = calculateFullVersion(baseVersion)
  snapshotVersion = baseVersion.endsWith('-SNAPSHOT')
}

allprojects {
  ext.displayName = null

  group = "org.spockframework"
  version = fullVersion

  apply from: script("common")

  if (javaVersion >= 1.8) {
    tasks.withType(Javadoc) {
      options.addStringOption('Xdoclint:none', '-quiet')
    }
  }
}

apply from: script("ide")

subprojects {
  apply plugin: "groovy"
  apply plugin: "signing"

  sourceCompatibility = targetJavaVersion
  targetCompatibility = targetJavaVersion

  sourceSets.all { ss ->
    for (v in variants.findAll { it <= variant } ) {
      java {
        srcDir "src/$ss.name$v/java"
      }
      groovy {
        srcDir "src/$ss.name$v/groovy"
      }
    }
  }

  repositories {
    mavenCentral()
    maven { url "https://oss.jfrog.org/oss-snapshot-local/" }
  }

  configurations {
    all*.exclude module: "junit-dep"
  }

  dependencies {
    compile(project.name == "spock-gradle" ? [] : libs.groovy)
  }

  signing {
    sign configurations.archives
  }

  signArchives {
    onlyIf { gradle.taskGraph.hasTask(uploadArchives) }
  }

  ext."signing.keyId" = "2EA0A67F"
  ext."signing.password" = System.getenv("SIGNING_PASSWORD")
  ext."signing.secretKeyRingFile" = "$rootDir/config/code-signing-secring.gpg"

  configureJavadoc(javadoc)
  configureGroovydoc(groovydoc)

  task sourcesJar(type: Jar) {
    classifier "sources"
    from sourceSets.main.allSource
  }

  task javadocJar(type: Jar) {
    classifier "javadoc"
    from javadoc
  }

  artifacts {
    archives sourcesJar, javadocJar
  }

  tasks.withType(Test) {
    reports {
      junitXml {
        destination = file("$destination/$variant")
      }
      html {
        destination = file("$destination/$variant")
      }
    }
  }
}

if (gradle.startParameter.taskNames == ["prepareForTravisCiBuild"]) {
  gradle.startParameter.taskNames = ["currentVersion"]
  if (System.getenv("TRAVIS_PULL_REQUEST") == "false" && System.getenv("TRAVIS_BRANCH") == "master") {
    logger.info("TRAVIS_COMMIT: ${System.getenv("TRAVIS_COMMIT")}, TRAVIS_COMMIT_MSG: ${System.getenv("TRAVIS_COMMIT_MSG")}")
    if (System.getenv("TRAVIS_COMMIT_MSG")?.contains(releaseTriggeringCommand)) {
      if (javaVersion == javaVersions.min() && variant == variants.max()) {
        project.ext["release.disableRemoteCheck"] = true	//TODO: Switch to setting in task properties
        gradle.startParameter.taskNames = ["createRelease"]
      }
    }
  }
}

if (gradle.startParameter.taskNames == ["travisCiBuild"]) {
  gradle.startParameter.taskNames = ["build"]
  subprojects {
    tasks.withType(Test) {
      maxParallelForks = 2
    }
  }
  if (System.getenv("TRAVIS_PULL_REQUEST") == "false" && System.getenv("TRAVIS_BRANCH") == "master") {
    if (javaVersion == javaVersions.min()) {
      gradle.startParameter.taskNames += ["uploadArchives"]
      if (variant == variants.max()) {
        if (!snapshotVersion) {
//          //enable "promoteRepository" after content of the first automatic release is verified
//          gradle.startParameter.taskNames += ["closeRepository", "tagRelease", "promoteRepository"]
          gradle.startParameter.taskNames += ["closeRepository", "tagRelease"]
        }
      }
    }
    if (javaVersion == javaVersions.max()) {
      if (variant == variants.max()) {
        //TODO: Would it be a problem to do it with javaVersions.min()? Should Javadocs for snapshot published?
        gradle.startParameter.taskNames += ["publishJavadoc", "publishDocs"]
      }
    }
  }
}

if (gradle.startParameter.taskNames == ["shippableCiBuild"]) {
  gradle.startParameter.taskNames = ["clean", "build"] // use clean because whole minion is cached
  task aggregateTestResults(type: Sync) {
    from { subprojects.test.reports.junitXml.destination }
    into "shippable/testresults"
    include "**/TEST-*.xml"
  }
  subprojects {
    tasks.withType(Test) {
      it.finalizedBy(aggregateTestResults)
    }
  }
  if (System.getenv("PULL_REQUEST") == "false") {
    if (javaVersion == javaVersions.min()) {
      gradle.startParameter.taskNames += ["uploadArchives"]
    }
    if (javaVersion == javaVersions.max()) {
      if (variant == variants.max()) {
        gradle.startParameter.taskNames += ["publishJavadoc", "publishDocs"]
        if (!snapshotVersion) {
          gradle.startParameter.taskNames += ["tagRelease"]
        }
      }
    }
  }
}

if (gradle.startParameter.taskNames == ["appveyorCiBuild"]) {
  gradle.startParameter.taskNames = ["build"]
}

task publishJavadoc(type: Exec) {
  dependsOn "javadoc"
  commandLine "sh", "-c",
"""
  git config user.email "dev@forum.spockframework.org"
  git config user.name "Spock Framework Robot"
  git fetch origin +gh-pages:gh-pages
  git checkout gh-pages
  rm -rf javadoc/$baseVersion
  mkdir -p javadoc/$baseVersion
  cp -r build/javadoc/$baseVersion javadoc/
  git add javadoc
  git commit -qm "Publish javadoc/$baseVersion"
  git push -q "https://\$GITHUB_TOKEN@github.com/spockframework/spock.git" gh-pages > /dev/null 2>&1
  git checkout master
"""
}
task publishDocs(type: Exec) {
  dependsOn "asciidoctor"
  commandLine "sh", "-c",
"""
  git config user.email "dev@forum.spockframework.org"
  git config user.name "Spock Framework Robot"
  git fetch origin +gh-pages:gh-pages
  git checkout gh-pages
  rm -rf docs/$baseVersion
  mkdir -p docs/$baseVersion
  cp -r build/asciidoc/html5/* docs/$baseVersion
  git add docs
  git commit -qm "Publish docs/$baseVersion"
  git push -q "https://\$GITHUB_TOKEN@github.com/spockframework/spock.git" gh-pages > /dev/null 2>&1
  git checkout master
"""
}
task tagRelease(type: Exec) {
  commandLine "sh", "-c",
"""
  git config user.email "dev@forum.spockframework.org"
  git config user.name "Spock Framework Robot"
  git push -q "https://\$GITHUB_TOKEN@github.com/spockframework/spock.git" HEAD:refs/heads/master --follow-tags > /dev/null 2>&1
"""
}

task javadoc(type: Javadoc) {
  title "Spock Framework API Documentation ($baseVersion)"
  destinationDir file("build/javadoc/$baseVersion")
  source subprojects.javadoc.source
  classpath = files(subprojects.javadoc.classpath)
}

configureJavadoc(javadoc)

task groovydoc(type: Groovydoc) {
  docTitle "Spock Framework API Documentation ($baseVersion)"
  windowTitle "Spock Framework API Documentation ($baseVersion)"
  destinationDir file("build/groovydoc/$baseVersion")
  source subprojects.groovydoc.source
  classpath = files(subprojects.groovydoc.classpath)
  groovyClasspath = project(":spock-core").groovydoc.groovyClasspath
}

configureGroovydoc(groovydoc)

asciidoctor {
  sourceDir = file("docs")
  logDocuments = true
  attributes "source-highlighter": "coderay", "linkcss": true
}

File script(String name) {
  project.file("gradle/${name}.gradle")
}

def configureJavadoc(task) {
  configure(task) {
    include "spock/**"
    configure(options) {
      links "http://docs.oracle.com/javase/6/docs/api/"
      links "http://docs.groovy-lang.org/docs/groovy-$groovyVersion/html/gapi/"
      links "http://junit.org/javadoc/latest/"
      links "http://hamcrest.org/JavaHamcrest/javadoc/1.3/"
    }
  }
}

def configureGroovydoc(task) {
  configure(task) {
    include "spock/**"
  }
}

tagRelease.mustRunAfter closeRepository
promoteRepository.mustRunAfter tagRelease

