<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.6.1">
<meta name="author" content="Peter Niederwieser, The Spock Framework Team">
<title>Extensions</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<link rel="stylesheet" href="./asciidoctor.css">
<link rel="stylesheet" href="./coderay-asciidoctor.css">
</head>
<body class="article">
<div id="header">
<h1>Extensions</h1>
<div class="details">
<span id="author" class="author">Peter Niederwieser, The Spock Framework Team</span><br>
<span id="revnumber">version 1.2-SNAPSHOT</span>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Spock comes with a powerful extension mechanism, which allows to hook into a spec&#8217;s lifecycle to enrich or alter its
behavior. In this chapter, we will first learn about Spock&#8217;s built-in extensions, and then dive into writing custom
extensions.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_spock_configuration_file"><a class="anchor" href="#_spock_configuration_file"></a><a class="link" href="#_spock_configuration_file">Spock Configuration File</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Some extensions can be configured with options in a Spock configuration file. The description for each extension will
mention how it can be configured. All those configurations are in a Groovy file that usually is called
<code>SpockConfig.groovy</code>. Spock first searches for a custom location given in a system property called <code>spock.configuration</code>
which is then used either as classpath location or if not found as file system location if it can be found there,
otherwise the default locations are investigated for a configuration file. Next it searches for the <code>SpockConfig.groovy</code>
in the root of the test execution classpath. If there is also no such file, you can at last have a <code>SpockConfig.groovy</code>
in your Spock user home. This by default is the directory <code>.spock</code> within your home directory, but can be changed using
the system property <code>spock.user.home</code> or if not set the environment property <code>SPOCK_USER_HOME</code>.</p>
</div>
<div class="sect2">
<h3 id="_stack_trace_filtering"><a class="anchor" href="#_stack_trace_filtering"></a><a class="link" href="#_stack_trace_filtering">Stack Trace Filtering</a></h3>
<div class="paragraph">
<p>You can configure Spock whether it should filter stack traces or not by using the configuration file. The default value
is <code>true</code>.</p>
</div>
<div class="listingblock">
<div class="title">Stack Trace Filtering Configuration</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">runner {
  filterStackTrace <span class="predefined-constant">false</span>
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_built_in_extensions"><a class="anchor" href="#_built_in_extensions"></a><a class="link" href="#_built_in_extensions">Built-In Extensions</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Most of Spock&#8217;s built-in extensions are <em>annotation-driven</em>. In other words, they are triggered by annotating a
spec class or method with a certain annotation. You can tell such an annotation by its <code>@ExtensionAnnotation</code>
meta-annotation.</p>
</div>
<div class="sect2">
<h3 id="_ignore"><a class="anchor" href="#_ignore"></a><a class="link" href="#_ignore">Ignore</a></h3>
<div class="paragraph">
<p>To temporarily prevent a feature method from getting executed, annotate it with <code>spock.lang.Ignore</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="annotation">@Ignore</span>
<span class="keyword">def</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">my feature</span><span class="delimiter">&quot;</span></span>() { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>For documentation purposes, a reason can be provided:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="annotation">@Ignore</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">TODO</span><span class="delimiter">&quot;</span></span>)
<span class="keyword">def</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">my feature</span><span class="delimiter">&quot;</span></span>() { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>To ignore a whole specification, annotate its class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="annotation">@Ignore</span>
<span class="type">class</span> <span class="class">MySpec</span> <span class="directive">extends</span> Specification { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>In most execution environments, ignored feature methods and specs will be reported as "skipped".</p>
</div>
<div class="paragraph">
<p>Care should be taken when ignoring feature methods in a spec class annotated with <code>spock.lang.Stepwise</code> since
later feature methods may depend on earlier feature methods having executed.</p>
</div>
</div>
<div class="sect2">
<h3 id="_ignorerest"><a class="anchor" href="#_ignorerest"></a><a class="link" href="#_ignorerest">IgnoreRest</a></h3>
<div class="paragraph">
<p>To ignore all but a (typically) small subset of methods, annotate the latter with <code>spock.lang.IgnoreRest</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">def</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">I'll be ignored</span><span class="delimiter">&quot;</span></span>() { ... }

<span class="annotation">@IgnoreRest</span>
<span class="keyword">def</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">I'll run</span><span class="delimiter">&quot;</span></span>() { ... }

<span class="keyword">def</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">I'll also be ignored</span><span class="delimiter">&quot;</span></span>() { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>@IgnoreRest</code> is especially handy in execution environments that don&#8217;t provide an (easy) way to run a subset of methods.</p>
</div>
<div class="paragraph">
<p>Care should be taken when ignoring feature methods in a spec class annotated with <code>spock.lang.Stepwise</code> since
later feature methods may depend on earlier feature methods having executed.</p>
</div>
</div>
<div class="sect2">
<h3 id="_ignoreif"><a class="anchor" href="#_ignoreif"></a><a class="link" href="#_ignoreif">IgnoreIf</a></h3>
<div class="paragraph">
<p>To ignore a feature method under certain conditions, annotate it with <code>spock.lang.IgnoreIf</code>,
followed by a predicate:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="annotation">@IgnoreIf</span>({ <span class="predefined-type">System</span>.getProperty(<span class="string"><span class="delimiter">&quot;</span><span class="content">os.name</span><span class="delimiter">&quot;</span></span>).contains(<span class="string"><span class="delimiter">&quot;</span><span class="content">windows</span><span class="delimiter">&quot;</span></span>) })
<span class="keyword">def</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">I'll run everywhere but on Windows</span><span class="delimiter">&quot;</span></span>() { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>To make predicates easier to read and write, the following properties are available inside the closure:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>sys</code> A map of all system properties</p>
</li>
<li>
<p><code>env</code> A map of all environment variables</p>
</li>
<li>
<p><code>os</code> Information about the operating system (see <code>spock.util.environment.OperatingSystem</code>)</p>
</li>
<li>
<p><code>jvm</code> Information about the JVM (see <code>spock.util.environment.Jvm</code>)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Using the <code>os</code> property, the previous example can be rewritten as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="annotation">@IgnoreIf</span>({ os.windows })
<span class="keyword">def</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">I'll run everywhere but on Windows</span><span class="delimiter">&quot;</span></span>() { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Care should be taken when ignoring feature methods in a spec class annotated with <code>spock.lang.Stepwise</code> since
later feature methods may depend on earlier feature methods having executed.</p>
</div>
</div>
<div class="sect2">
<h3 id="_requires"><a class="anchor" href="#_requires"></a><a class="link" href="#_requires">Requires</a></h3>
<div class="paragraph">
<p>To execute a feature method under certain conditions, annotate it with <code>spock.lang.Requires</code>,
followed by a predicate:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="annotation">@Requires</span>({ os.windows })
<span class="keyword">def</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">I'll only run on Windows</span><span class="delimiter">&quot;</span></span>() { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Requires</code> works exactly like <code>IgnoreIf</code>, except that the predicate is inverted. In general, it is preferable
to state the conditions under which a method gets executed, rather than the conditions under which it gets ignored.</p>
</div>
</div>
<div class="sect2">
<h3 id="_pendingfeature"><a class="anchor" href="#_pendingfeature"></a><a class="link" href="#_pendingfeature">PendingFeature</a></h3>
<div class="paragraph">
<p>To indicate that the feature is not fully implemented yet and should not be reported as error, annotate it with <code>spock.lang.PendingFeature</code>.</p>
</div>
<div class="paragraph">
<p>The use case is to annotate tests that can not yet run but should already be committed.
The main difference to <code>Ignore</code> is that the test are executed, but test failures are ignored.
If the test passes without an error, then it will be reported as failure since the <code>PendingFeature</code> annotation should be removed.
This way the tests will become part of the normal tests instead of being ignored forever.</p>
</div>
<div class="paragraph">
<p>Groovy has the <code>groovy.transform.NotYetImplemented</code> annotation which is similar but behaves a differently.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>it will mark failing tests as passed</p>
</li>
<li>
<p>if at least one iteration of a data-driven test passes it will be reported as error</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>PendingFeature</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>it will mark failing tests as skipped</p>
</li>
<li>
<p>if at least one iteration of a data-driven test fails it will be reported as skipped</p>
</li>
<li>
<p>if every iteration of a data-driven test passes it will be reported as error</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="annotation">@PendingFeature</span>
<span class="keyword">def</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">not implemented yet</span><span class="delimiter">&quot;</span></span>() { ... }</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_stepwise"><a class="anchor" href="#_stepwise"></a><a class="link" href="#_stepwise">Stepwise</a></h3>
<div class="paragraph">
<p>To execute features in the order that they are declared, annotate a spec class with <code>spock.lang.Stepwise</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="annotation">@Stepwise</span>
<span class="type">class</span> <span class="class">RunInOrderSpec</span> <span class="directive">extends</span> Specification {
  <span class="keyword">def</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">I run first</span><span class="delimiter">&quot;</span></span>()  { ... }
  <span class="keyword">def</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">I run second</span><span class="delimiter">&quot;</span></span>() { ... }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Stepwise</code> only affects the class carrying the annotation; not sub or super classes.  Features after the first
failure are skipped.</p>
</div>
<div class="paragraph">
<p><code>Stepwise</code> does not override the behaviour of annotations such as <code>Ignore</code>, <code>IgnoreRest</code>, and <code>IgnoreIf</code>, so care
should be taken when ignoring feature methods in spec classes annotated with <code>Stepwise</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_timeout"><a class="anchor" href="#_timeout"></a><a class="link" href="#_timeout">Timeout</a></h3>
<div class="paragraph">
<p>To fail a feature method, fixture, or class that exceeds a given execution duration, use <code>spock.lang.Timeout</code>,
followed by a duration, and optionally a time unit. The default time unit is seconds.</p>
</div>
<div class="paragraph">
<p>When applied to a feature method, the timeout is per execution of one iteration, excluding time spent in fixture methods:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="annotation">@Timeout</span>(<span class="integer">5</span>)
<span class="keyword">def</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">I fail if I run for more than five seconds</span><span class="delimiter">&quot;</span></span>() { ... }

<span class="annotation">@Timeout</span>(value = <span class="integer">100</span>, unit = <span class="predefined-type">TimeUnit</span>.MILLISECONDS)
<span class="keyword">def</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">I better be quick</span><span class="delimiter">&quot;</span></span> { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Applying <code>Timeout</code> to a spec class has the same effect as applying it to each feature that is not already annotated
with <code>Timeout</code>, excluding time spent in fixtures:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="annotation">@Timeout</span>(<span class="integer">10</span>)
<span class="type">class</span> <span class="class">TimedSpec</span> <span class="directive">extends</span> Specification {
  <span class="keyword">def</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">I fail after ten seconds</span><span class="delimiter">&quot;</span></span>() { ... }
  <span class="keyword">def</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Me too</span><span class="delimiter">&quot;</span></span>() { ... }

  <span class="annotation">@Timeout</span>(value = <span class="integer">250</span>, unit = MILLISECONDS)
  <span class="keyword">def</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">I fail much faster</span><span class="delimiter">&quot;</span></span>() { ... }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When applied to a fixture method, the timeout is per execution of the fixture method.</p>
</div>
<div class="paragraph">
<p>When a timeout is reported to the user, the stack trace shown reflects the execution stack of the test framework when
the timeout was exceeded.</p>
</div>
</div>
<div class="sect2">
<h3 id="_retry"><a class="anchor" href="#_retry"></a><a class="link" href="#_retry">Retry</a></h3>
<div class="paragraph">
<p>The <code>@Retry</code> extensions can be used for flaky integration tests, where remote systems can fail sometimes.
By default it retries an iteration <code>3</code> times with <code>0</code> delay if either an <code>Exception</code> or <code>AssertionError</code> has been thrown, all this is configurable.
In addition, an optional <code>condition</code> closure can be used to determine if a feature should be retried.
It also provides special support for data driven features, offering to either retry all iterations or just the failing ones.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="type">class</span> <span class="class">FlakyIntegrationSpec</span> <span class="directive">extends</span> Specification {
  <span class="annotation">@Retry</span>
  <span class="keyword">def</span> <span class="function">retry3Times</span>() { ... }

  <span class="annotation">@Retry</span>(count = <span class="integer">5</span>)
  <span class="keyword">def</span> <span class="function">retry5Times</span>() { ... }

  <span class="annotation">@Retry</span>(exceptions=[<span class="exception">IOException</span>])
  <span class="keyword">def</span> <span class="function">onlyRetryIOException</span>() { ... }

  <span class="annotation">@Retry</span>(condition = { failure.message.contains(<span class="string"><span class="delimiter">'</span><span class="content">foo</span><span class="delimiter">'</span></span>) })
  <span class="keyword">def</span> <span class="function">onlyRetryIfConditionOnFailureHolds</span>() { ... }

  <span class="annotation">@Retry</span>(condition = { instance.field != <span class="predefined-constant">null</span> })
  <span class="keyword">def</span> <span class="function">onlyRetryIfConditionOnInstanceHolds</span>() { ... }

  <span class="annotation">@Retry</span>
  <span class="keyword">def</span> <span class="function">retryFailingIterations</span>() {
    ...
    where:
    data &lt;&lt; sql.select()
  }

  <span class="annotation">@Retry</span>(mode = Retry.Mode.FEATURE)
  <span class="keyword">def</span> <span class="function">retryWholeFeature</span>() {
    ...
    where:
    data &lt;&lt; sql.select()
  }

  <span class="annotation">@Retry</span>(delay = <span class="integer">1000</span>)
  <span class="keyword">def</span> <span class="function">retryAfter1000MsDelay</span>() { ... }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Retries can also be applied to spec classes which has the same effect as applying it to each feature method that isn&#8217;t
already annotated with {@code Retry}.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="annotation">@Retry</span>
<span class="type">class</span> <span class="class">FlakyIntegrationSpec</span> <span class="directive">extends</span> Specification {
  <span class="keyword">def</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">will be retried with config from class</span><span class="delimiter">&quot;</span></span>() {
    ...
  }
  <span class="annotation">@Retry</span>(count = <span class="integer">5</span>)
  <span class="keyword">def</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">will be retried using its own config</span><span class="delimiter">&quot;</span></span>() {
    ...
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>A {@code @Retry} annotation that is declared on a spec class is applied to all features in all subclasses as well,
unless a subclass declares its own annotation. If so, the retries defined in the subclass are applied to all feature
methods declared in the subclass as well as inherited ones.</p>
</div>
<div class="paragraph">
<p>Given the following example, running <code>FooIntegrationSpec</code> will execute both <code>inherited</code> and <code>foo</code> with one retry.
Running <code>BarIntegrationSpec</code> will execute <code>inherited</code> and <code>bar</code> with two retries.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="annotation">@Retry</span>(count = <span class="integer">1</span>)
<span class="directive">abstract</span> <span class="type">class</span> <span class="class">AbstractIntegrationSpec</span> <span class="directive">extends</span> Specification {
  <span class="keyword">def</span> <span class="function">inherited</span>() {
    ...
  }
}

<span class="type">class</span> <span class="class">FooIntegrationSpec</span> <span class="directive">extends</span> AbstractIntegrationSpec {
  <span class="keyword">def</span> <span class="function">foo</span>() {
    ...
  }
}

<span class="annotation">@Retry</span>(count = <span class="integer">2</span>)
<span class="type">class</span> <span class="class">BarIntegrationSpec</span> <span class="directive">extends</span> AbstractIntegrationSpec {
  <span class="keyword">def</span> <span class="function">bar</span>() {
    ...
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Check <a href="https://github.com/spockframework/spock/blob/master/spock-specs/src/test/groovy/org/spockframework/smoke/extension/RetryFeatureExtensionSpec.groovy">RetryFeatureExtensionSpec</a> for more examples.</p>
</div>
</div>
<div class="sect2">
<h3 id="_use"><a class="anchor" href="#_use"></a><a class="link" href="#_use">Use</a></h3>
<div class="paragraph">
<p>To activate one or more Groovy categories within the scope of a feature method or spec, use <code>spock.util.mop.Use</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="type">class</span> <span class="class">ListExtensions</span> {
  <span class="directive">static</span> avg(<span class="predefined-type">List</span> list) { list.sum() / list.size() }
}

<span class="type">class</span> <span class="class">MySpec</span> <span class="directive">extends</span> Specification {
  <span class="annotation">@Use</span>(listExtensions)
  <span class="keyword">def</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">can use avg() method</span><span class="delimiter">&quot;</span></span>() {
    <span class="key">expect</span>:
    [<span class="integer">1</span>, <span class="integer">2</span>, <span class="integer">3</span>].avg() == <span class="integer">2</span>
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This can be useful for stubbing of dynamic methods, which are usually provided by the runtime environment (e.g. Grails).
It has no effect when applied to a helper method. However, when applied to a spec class, it will also affect its helper
methods.</p>
</div>
</div>
<div class="sect2">
<h3 id="_confinemetaclasschanges"><a class="anchor" href="#_confinemetaclasschanges"></a><a class="link" href="#_confinemetaclasschanges">ConfineMetaClassChanges</a></h3>
<div class="paragraph">
<p>To confine meta class changes to the scope of a feature method or spec class, use <code>spock.util.mop.ConfineMetaClassChanges</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="annotation">@Stepwise</span>
<span class="type">class</span> <span class="class">FooSpec</span> <span class="directive">extends</span> Specification {
  <span class="annotation">@ConfineMetaClassChanges</span>([<span class="predefined-type">String</span>])
  <span class="keyword">def</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">I run first</span><span class="delimiter">&quot;</span></span>() {
    <span class="key">when</span>:
    <span class="predefined-type">String</span>.metaClass.someMethod = { delegate }

    <span class="key">then</span>:
    <span class="predefined-type">String</span>.metaClass.hasMetaMethod(<span class="string"><span class="delimiter">'</span><span class="content">someMethod</span><span class="delimiter">'</span></span>)
  }

  <span class="keyword">def</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">I run second</span><span class="delimiter">&quot;</span></span>() {
    <span class="key">when</span>:
    <span class="string"><span class="delimiter">&quot;</span><span class="content">Foo</span><span class="delimiter">&quot;</span></span>.someMethod()

    <span class="key">then</span>:
    thrown(MissingMethodException)
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When applied to a spec class, the meta classes are restored to the state that they were in before <code>setupSpec</code> was executed,
after <code>cleanupSpec</code> is executed.</p>
</div>
<div class="paragraph">
<p>When applied to a feature method, the meta classes are restored to as they were after <code>setup</code> was executed,
before <code>cleanup</code> is executed.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<div class="title">Caution</div>
</td>
<td class="content">
Temporarily changing the meta classes is only safe when specs are
run in a single thread per JVM. Even though many execution environments do limit themselves to one thread
per JVM, keep in mind that Spock cannot enforce this.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_restoresystemproperties"><a class="anchor" href="#_restoresystemproperties"></a><a class="link" href="#_restoresystemproperties">RestoreSystemProperties</a></h3>
<div class="paragraph">
<p>Saves system properties before the annotated feature method (including any setup and cleanup methods) gets run,
and restores them afterwards.</p>
</div>
<div class="paragraph">
<p>Applying this annotation to a spec class has the same effect as applying it to all its feature methods.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="annotation">@RestoreSystemProperties</span>
<span class="keyword">def</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">determines family based on os.name system property</span><span class="delimiter">&quot;</span></span>() {
  <span class="key">given</span>:
  <span class="predefined-type">System</span>.setProperty(<span class="string"><span class="delimiter">'</span><span class="content">os.name</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">Windows 7</span><span class="delimiter">'</span></span>)

  <span class="key">expect</span>:
  OperatingSystem.current.family == OperatingSystem.Family.WINDOWS
}</code></pre>
</div>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<div class="title">Caution</div>
</td>
<td class="content">
Temporarily changing the values of system properties is only safe when specs are
run in a single thread per JVM. Even though many execution environments do limit themselves to one thread
per JVM, keep in mind that Spock cannot enforce this.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_autoattach"><a class="anchor" href="#_autoattach"></a><a class="link" href="#_autoattach">AutoAttach</a></h3>
<div class="paragraph">
<p>Automatically attaches a detached mock to the current <code>Specification</code>. Use this if there is no direct framework
support available. Spring and Guice dependency injection is automatically handled by the
<a href="module_spring.html#_spring_module">Spring Module</a> and <a href="modules.html#_guice_module">Guice Module</a> respectively.</p>
</div>
</div>
<div class="sect2">
<h3 id="_autocleanup"><a class="anchor" href="#_autocleanup"></a><a class="link" href="#_autocleanup">AutoCleanup</a></h3>
<div class="paragraph">
<p>Automatically clean up a field or property at the end of its lifetime by using <code>spock.lang.AutoCleanup</code>.</p>
</div>
<div class="paragraph">
<p>By default, an object is cleaned up by invoking its parameterless <code>close()</code> method. If some other
method should be called instead, override the annotation&#8217;s <code>value</code> attribute:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="comment">// invoke foo.dispose()</span>
<span class="annotation">@AutoCleanup</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">dispose</span><span class="delimiter">&quot;</span></span>)
<span class="keyword">def</span> foo</code></pre>
</div>
</div>
<div class="paragraph">
<p>If multiple fields or properties are annotated with <code>AutoCleanup</code>, their objects are cleaned up sequentially, in reverse
field/property declaration order, starting from the most derived class class and walking up the inheritance chain.</p>
</div>
<div class="paragraph">
<p>If a cleanup operation fails with an exception, the exception is reported by default, and cleanup proceeds with the next
annotated object. To prevent cleanup exceptions from being reported, override the annotation&#8217;s <code>quiet</code> attribute:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="annotation">@AutoCleanup</span>(quiet = <span class="predefined-constant">true</span>)
<span class="keyword">def</span> ignoreMyExceptions</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_title_and_narrative"><a class="anchor" href="#_title_and_narrative"></a><a class="link" href="#_title_and_narrative">Title and Narrative</a></h3>
<div class="paragraph">
<p>To attach a natural-language name to a spec, use <code>spock.lang.Title</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="annotation">@Title</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">This is easy to read</span><span class="delimiter">&quot;</span></span>)
<span class="type">class</span> <span class="class">ThisIsHarderToReadSpec</span> <span class="directive">extends</span> Specification {
  ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Similarly, to attach a natural-language description to a spec, use <code>spock.lang.Narrative</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="annotation">@Narrative</span>(<span class="string"><span class="delimiter">&quot;&quot;&quot;</span><span class="content">
As a user
I want foo
So that bar
</span><span class="delimiter">&quot;&quot;&quot;</span></span>)
<span class="type">class</span> <span class="class">GiveTheUserFooSpec</span>() { ... }</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_see"><a class="anchor" href="#_see"></a><a class="link" href="#_see">See</a></h3>
<div class="paragraph">
<p>To link to one or more references to external information related to a specification or feature, use <code>spock.lang.See</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="annotation">@See</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">http://spockframework.org/spec</span><span class="delimiter">&quot;</span></span>)
<span class="type">class</span> <span class="class">MoreInformationAvailableSpec</span> <span class="directive">extends</span> Specification {
  <span class="annotation">@See</span>([<span class="string"><span class="delimiter">&quot;</span><span class="content">http://en.wikipedia.org/wiki/Levenshtein_distance</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.levenshtein.net/</span><span class="delimiter">&quot;</span></span>])
  <span class="keyword">def</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Even more information is available on the feature</span><span class="delimiter">&quot;</span></span>() { ... }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_issue"><a class="anchor" href="#_issue"></a><a class="link" href="#_issue">Issue</a></h3>
<div class="paragraph">
<p>To indicate that a feature or spec relates to one or more issues in an external tracking system, use <code>spock.lang.Issue</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="annotation">@Issue</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">http://my.issues.org/FOO-1</span><span class="delimiter">&quot;</span></span>)
<span class="type">class</span> <span class="class">MySpec</span> {
  <span class="annotation">@Issue</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">http://my.issues.org/FOO-2</span><span class="delimiter">&quot;</span></span>)
  <span class="keyword">def</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Foo should do bar</span><span class="delimiter">&quot;</span></span>() { ... }

  <span class="annotation">@Issue</span>([<span class="string"><span class="delimiter">&quot;</span><span class="content">http://my.issues.org/FOO-3</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">http://my.issues.org/FOO-4</span><span class="delimiter">&quot;</span></span>])
  <span class="keyword">def</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">I have two related issues</span><span class="delimiter">&quot;</span></span>() { ... }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you have a common prefix URL for all issues in a project, you can use the <a href="#_spock_configuration_file">Spock Configuration File</a> to set it up
for all at once. If it is set, it is prepended to the value of the <code>@Issue</code> annotation when building the URL.</p>
</div>
<div class="paragraph">
<p>If the <code>issueNamePrefix</code> is set, it is prepended to the value of the <code>@Issue</code> annotation when building the name for the
issue.</p>
</div>
<div class="listingblock">
<div class="title">Issue Configuration</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">report {
    issueNamePrefix <span class="string"><span class="delimiter">'</span><span class="content">Bug </span><span class="delimiter">'</span></span>
    issueUrlPrefix <span class="string"><span class="delimiter">'</span><span class="content">http://my.issues.org/</span><span class="delimiter">'</span></span>
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_subject"><a class="anchor" href="#_subject"></a><a class="link" href="#_subject">Subject</a></h3>
<div class="paragraph">
<p>To indicate one or more subjects of a spec, use <code>spock.lang.Subject</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="annotation">@Subject</span>([Foo, Bar]) { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Additionally, <code>Subject</code> can be applied to fields and local variables:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="annotation">@Subject</span>
Foo myFoo</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Subject</code> currently has only informational purposes.</p>
</div>
</div>
<div class="sect2">
<h3 id="_rule"><a class="anchor" href="#_rule"></a><a class="link" href="#_rule">Rule</a></h3>
<div class="paragraph">
<p>Spock understands <code>@org.junit.Rule</code> annotations on non-<code>@Shared</code> instance fields. The according rules are run at the
iteration interception point in the Spock lifecycle. This means that the rules before-actions are done before the
execution of <code>setup</code> methods and the after-actions are done after the execution of <code>cleanup</code> methods.</p>
</div>
</div>
<div class="sect2">
<h3 id="_classrule"><a class="anchor" href="#_classrule"></a><a class="link" href="#_classrule">ClassRule</a></h3>
<div class="paragraph">
<p>Spock understands <code>@org.junit.ClassRule</code> annotations on <code>@Shared</code> fields. The according rules are run at the
specification interception point in the Spock lifecycle. This means that the rules before-actions are done before the
execution of <code>setupSpec</code> methods and the after-actions are done after the execution of <code>cleanupSpec</code> methods.</p>
</div>
</div>
<div class="sect2">
<h3 id="_include_and_exclude"><a class="anchor" href="#_include_and_exclude"></a><a class="link" href="#_include_and_exclude">Include and Exclude</a></h3>
<div class="paragraph">
<p>Spock is capable of including and excluding specifications according to their classes, super-classes and interfaces and
according to annotations that are applied to the specification. Spock is also capable of including and excluding
individual features according to annotations that are applied to the feature method. The configuration for what to
include or exclude is done according to the <a href="#_spock_configuration_file">Spock Configuration File</a> section.</p>
</div>
<div class="listingblock">
<div class="title">Include / Exclude Configuration</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">import</span> <span class="include">some.pkg.Fast</span>
<span class="keyword">import</span> <span class="include">some.pkg.IntegrationSpec</span>

runner {
  include Fast <span class="comment">// could be either an annotation or a (base) class</span>
  exclude {
    annotation some.pkg.Slow
    baseClass IntegrationSpec
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_optimize_run_order"><a class="anchor" href="#_optimize_run_order"></a><a class="link" href="#_optimize_run_order">Optimize Run Order</a></h3>
<div class="paragraph">
<p>Spock can remember which features last failed and how often successively and also how long a feature needed to be
tested. For successive runs Spock will then first run features that failed at last run and first features that failed
more often successively. Within the previously failed or non-failed features Spock will run the fastest tests first.
This behaviour can be enabled according to the <a href="#_spock_configuration_file">Spock Configuration File</a> section. The default value is <code>false</code>.</p>
</div>
<div class="listingblock">
<div class="title">Optimize Run Order Configuration</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">runner {
  optimizeRunOrder <span class="predefined-constant">true</span>
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_report_log"><a class="anchor" href="#_report_log"></a><a class="link" href="#_report_log">Report Log</a></h3>
<div class="paragraph">
<p>Spock can create a report log of the executed tests in JSON format. This report contains also things like
<a href="#_title_and_narrative"><code>@Title</code></a>, <a href="#_title_and_narrative"><code>@Narrative</code></a>, <a href="#_see"><code>@See</code></a> and <a href="#_issue"><code>@Issue</code></a> values or
<a href="spock_primer.html#_blocks">block descriptors</a>.
This report can be enabled according to the <a href="#_spock_configuration_file">Spock Configuration File</a> section. The default is to not generate this
report.</p>
</div>
<div class="paragraph">
<p>For the report to be generated, you have to enable it and set at least the <code>logFileDir</code> and <code>logFileName</code>. <code>enabled</code> can
also be set via the system property <code>spock.logEnabled</code>, <code>logFileDir</code> can also be set via the system property
<code>spock.logFileDir</code> and <code>logFileName</code> can also be set via the system property <code>spock.logFileName</code>.</p>
</div>
<div class="paragraph">
<p>If a <code>logFileSuffix</code> is set (or the system property <code>spock.logFileSuffix</code>), it is appended to the base filename,
separated by a dash. If the suffix contains the string <code>#timestamp</code>, this is replaced by the current date and time in
<code>UTC</code> automatically. If you instead want to have your local date and time, you can use the setting from the example
below.</p>
</div>
<div class="listingblock">
<div class="title">Report Log Configuration</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">report {
    enabled <span class="predefined-constant">true</span>
    logFileDir <span class="string"><span class="delimiter">'</span><span class="content">.</span><span class="delimiter">'</span></span>
    logFileName <span class="string"><span class="delimiter">'</span><span class="content">spock-report.json</span><span class="delimiter">'</span></span>
    logFileSuffix <span class="keyword">new</span> <span class="predefined-type">Date</span>().format(<span class="string"><span class="delimiter">'</span><span class="content">yyyy-MM-dd_HH_mm_ss</span><span class="delimiter">'</span></span>)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_third_party_extensions"><a class="anchor" href="#_third_party_extensions"></a><a class="link" href="#_third_party_extensions">Third-Party Extensions</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>You can find a list of third-party extensions in the <a href="https://github.com/spockframework/spock/wiki/Third-Party-Extensions">Spock Wiki</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_writing_custom_extensions"><a class="anchor" href="#_writing_custom_extensions"></a><a class="link" href="#_writing_custom_extensions">Writing Custom Extensions</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>There are two types of extensions that can be created for usage with Spock. These are global extensions and annotation
driven local extensions. For both extension types you implement a specific interface which defines some callback
methods. In your implementation of those methods you can set up the magic of your extension, for example by adding
interceptors to various interception points that are described below.</p>
</div>
<div class="paragraph">
<p>Which type of annotation you create depends on your use case. If you want to do something once during the Spock run - at
the start or end - or want to apply something to all executed specifications without the user of the extension having to
do anything besides including your extension in the classpath, then you should opt for a global extension. If you
instead want to apply your magic only by choice of the user, then you should implement an annotation driven local
extension.</p>
</div>
<div class="sect2">
<h3 id="_global_extensions"><a class="anchor" href="#_global_extensions"></a><a class="link" href="#_global_extensions">Global Extensions</a></h3>
<div class="paragraph">
<p>To create a global extension you need to create a class that implements the interface <code>IGlobalExtension</code> and put its
fully-qualified class name in a file <code>META-INF/services/org.spockframework.runtime.extension.IGlobalExtension</code> in the
class path. As soon as these two conditions are satisfied, the extension is automatically loaded and used when Spock is
running. For convenience there is also the class <code>AbstractGlobalExtension</code>, which provides empty implementations for all
methods in the interface, so that only the needed ones need to be overridden.</p>
</div>
<div class="paragraph">
<p><code>IGlobalExtension</code> has the following three methods:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>start()</code></dt>
<dd>
<p>This is called once at the very start of the Spock execution.</p>
</dd>
<dt class="hdlist1"><code>visitSpec(SpecInfo spec)</code></dt>
<dd>
<p>This is called once for each specification. In this method you can prepare a specification with your extension magic,
like attaching interceptors to various interception points as described in the chapter <a href="#_interceptors">Interceptors</a>.</p>
</dd>
<dt class="hdlist1"><code>stop()</code></dt>
<dd>
<p>This is called once at the very end of the Spock execution.</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_annotation_driven_local_extensions"><a class="anchor" href="#_annotation_driven_local_extensions"></a><a class="link" href="#_annotation_driven_local_extensions">Annotation Driven Local Extensions</a></h3>
<div class="paragraph">
<p>To create an annotation driven local extension you need to create a class that implements the interface
<code>IAnnotationDrivenExtension</code>. As type argument to the interface you need to supply an annotation class that has
<code>@Retention</code> set to <code>RUNTIME</code>, <code>@Target</code> set to one or more of <code>FIELD</code>, <code>METHOD</code> and <code>TYPE</code> - depending on where you
want your annotation to be applicable - and <code>@ExtensionAnnotation</code> applied, with the <code>IAnnotationDrivenExtension</code> class
as argument. Of course the annotation class can have some attributes with which the user can further configure the
behaviour of the extension for each annotation application. For convenience there is also the class
<code>AbstractAnnotationDrivenExtension</code>, which provides empty implementations for all methods in the interface, so that only
the needed ones need to be overridden.</p>
</div>
<div class="paragraph">
<p>Your annotation can be applied to a specification, a feature method, a fixture method or a field. On all other places
like helper methods or other places if the <code>@Target</code> is set accordingly, the annotation will be ignored and has no
effect other than being visible in the source code.</p>
</div>
<div class="paragraph">
<p><code>IAnnotationDrivenExtension</code> has the following five methods, where in each you can prepare a specification with your
extension magic, like attaching interceptors to various interception points as described in the chapter
<a href="#_interceptors">Interceptors</a>:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>visitSpecAnnotation(T annotation, SpecInfo spec)</code></dt>
<dd>
<p>This is called once for each specification where the annotation is applied with the annotation instance as first
parameter and the specification info object as second parameter.</p>
</dd>
<dt class="hdlist1"><code>visitFeatureAnnotation(T annotation, FeatureInfo feature)</code></dt>
<dd>
<p>This is called once for each feature method where the annotation is applied with the annotation instance as first
parameter and the feature info object as second parameter.</p>
</dd>
<dt class="hdlist1"><code>visitFixtureAnnotation(T annotation, MethodInfo fixtureMethod)</code></dt>
<dd>
<p>This is called once for each fixture method where the annotation is applied with the annotation instance as first
parameter and the fixture method info object as second parameter.</p>
</dd>
<dt class="hdlist1"><code>visitFieldAnnotation(T annotation, FieldInfo field)</code></dt>
<dd>
<p>This is called once for each field where the annotation is applied with the annotation instance as first parameter and
the field info object as second parameter.</p>
</dd>
<dt class="hdlist1"><code>visitSpec(SpecInfo spec)</code></dt>
<dd>
<p>This is called once for each specification within which the annotation is applied to at least one of the supported
places like defined above. It gets the specification info object as sole parameter. This method is called after all
other methods of this interface for each applied annotation are processed.</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_configuration_objects"><a class="anchor" href="#_configuration_objects"></a><a class="link" href="#_configuration_objects">Configuration Objects</a></h3>
<div class="paragraph">
<p>You can add own sections in the <a href="#_spock_configuration_file">Spock Configuration File</a> for your extension by creating POJOs or POGOs that are
annotated with <code>@ConfigurationObject</code> and have a default constructor (either implicitly or explicitly). The argument to
the annotation is the name of the top-level section that is added to the Spock configuration file syntax. The default
values for the configuration options are defined in the class by initializing the fields at declaration time or in the
constructor. In the Spock configuration file those values can then be edited by the user of your extension.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
It is an error to have multiple configuration objects with the same name, so choose wisely if you pick one and
probably prefix it with some package-like name to minimize the risk for name clashes with other extensions or the core
Spock code.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To use the values of the configuration object in your extension, just define an uninitialized instance field of that
type. Spock will then automatically create exactly one instance of the configuration object per Spock run, apply the
settings from the configuration file to it (before the <code>start()</code> methods of global extensions are called) and inject
that instance into the extension class instances.</p>
</div>
<div class="paragraph">
<p>A configuration object cannot be used exclusively in an annotation driven local extension, but it has to be used in at
least one global extension to properly get initialized and populated with the settings from the configuration file. But
if the configuration object is used in a global extension, you can also use it just fine in an annotation driven local
extension. If the configuration object is only used in an annotation driven local extension, you will get an exception
when then configuration object is to be injected into the extension and you will also get an error when the
configuration file is evaluated and it contains the section, as the configuration object is not properly registered yet.</p>
</div>
</div>
<div class="sect2">
<h3 id="_interceptors"><a class="anchor" href="#_interceptors"></a><a class="link" href="#_interceptors">Interceptors</a></h3>
<div class="paragraph">
<p>For applying the magic of your extension, there are various interception points, where you can attach interceptors from
the extension methods described above to hook into the Spock lifecycle. For each interception point there can of course
be multiple interceptors added by arbitrary Spock extensions (shipped or 3rd party). Their order is currently depending
on the order they are added, but there should not be made any order assumptions within one interception point.</p>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="images/spock_interceptors.png" alt="Spock Interceptors">
</div>
<div class="title">Figure 1. Spock Interceptors</div>
</div>
<div class="paragraph">
<p>An ellipsis in the figure means that the block before it can be repeated an arbitrary amount of times.</p>
</div>
<div class="paragraph">
<p>The <code>&#8230;&#8203; method interceptors</code> are of course only run if there are actual methods of this type to be executed (the white
boxes) and those can <a href="#_injecting_method_parameters">inject parameters</a> to be given to the method that will be run.</p>
</div>
<div class="paragraph">
<p>The difference between shared initializer interceptor and shared initializer method interceptor and between initializer
interceptor and initializer method interceptor - as there can be at most one of those methods each - is, that there are
only the two methods if there are <code>@Shared</code>, respectively non-<code>@Shared</code>, fields that get values assigned at declaration
time. The compiler will put those initializations in a generated method and call it at the proper place in the
lifecycle. So if there are no such initializations, no method is generated and thus the method interceptor is never
called. The non-method interceptors are always called at the proper place in the lifecycle to do work that has to be
done at that time.</p>
</div>
<div class="paragraph">
<p>To create an interceptor to be attached to an interception point, you need to create a class that implements the
interface <code>IMethodInterceptor</code>. This interface has the sole method <code>intercept(IMethodInvocation invocation)</code>. The
<code>invocation</code> parameter can be used to get and modify the current state of execution. Each interceptor <strong>must</strong> call the
method <code>invocation.proceed()</code>, which will go on in the lifecycle, except you really want to prevent further execution of
the nested elements like shown in the figure above. But this should be a very rare use case.</p>
</div>
<div class="paragraph">
<p>If you write an interceptor that can be used at different interception points and should do different work at different
interception points, there is also the convenience class <code>AbstractMethodInterceptor</code>, which you can extend and which
provides various methods for overriding that are called for the various interception points. Most of these methods have
a double meaning, like <code>interceptSetupMethod</code> which is called for the <code>setup interceptor</code> and the <code>setup method
interceptor</code>. If you attach your interceptor to both of them and need a differentiation, you can check for
<code>invocation.method.reflection</code>, which will be set in the method interceptor case and <code>null</code> otherwise. Alternatively you
can of course build two different interceptors or add a parameter to your interceptor and create two instances, telling
each at addition time whether it is attached to the method interceptor or the other one.</p>
</div>
<div class="listingblock">
<div class="title">Add All Interceptors</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="type">class</span> <span class="class">I</span> <span class="directive">extends</span> AbstractMethodInterceptor { I(<span class="keyword">def</span> s) {} }

specInfo.addSharedInitializerInterceptor <span class="keyword">new</span> I(<span class="string"><span class="delimiter">'</span><span class="content">shared initializer</span><span class="delimiter">'</span></span>)
specInfo.sharedInitializerMethod?.addInterceptor <span class="keyword">new</span> I(<span class="string"><span class="delimiter">'</span><span class="content">shared initializer method</span><span class="delimiter">'</span></span>)
specInfo.addInterceptor <span class="keyword">new</span> I(<span class="string"><span class="delimiter">'</span><span class="content">specification</span><span class="delimiter">'</span></span>)
specInfo.addSetupSpecInterceptor <span class="keyword">new</span> I(<span class="string"><span class="delimiter">'</span><span class="content">setup spec</span><span class="delimiter">'</span></span>)
specInfo.setupSpecMethods*.addInterceptor <span class="keyword">new</span> I(<span class="string"><span class="delimiter">'</span><span class="content">setup spec method</span><span class="delimiter">'</span></span>)
specInfo.allFeatures*.addInterceptor <span class="keyword">new</span> I(<span class="string"><span class="delimiter">'</span><span class="content">feature</span><span class="delimiter">'</span></span>)
specInfo.addInitializerInterceptor <span class="keyword">new</span> I(<span class="string"><span class="delimiter">'</span><span class="content">initializer</span><span class="delimiter">'</span></span>)
specInfo.initializerMethod?.addInterceptor <span class="keyword">new</span> I(<span class="string"><span class="delimiter">'</span><span class="content">initializer method</span><span class="delimiter">'</span></span>)
specInfo.allFeatures*.addIterationInterceptor <span class="keyword">new</span> I(<span class="string"><span class="delimiter">'</span><span class="content">iteration</span><span class="delimiter">'</span></span>)
specInfo.addSetupInterceptor <span class="keyword">new</span> I(<span class="string"><span class="delimiter">'</span><span class="content">setup</span><span class="delimiter">'</span></span>)
specInfo.setupMethods*.addInterceptor <span class="keyword">new</span> I(<span class="string"><span class="delimiter">'</span><span class="content">setup method</span><span class="delimiter">'</span></span>)
specInfo.allFeatures*.featureMethod*.addInterceptor <span class="keyword">new</span> I(<span class="string"><span class="delimiter">'</span><span class="content">feature method</span><span class="delimiter">'</span></span>)
specInfo.addCleanupInterceptor <span class="keyword">new</span> I(<span class="string"><span class="delimiter">'</span><span class="content">cleanup</span><span class="delimiter">'</span></span>)
specInfo.cleanupMethods*.addInterceptor <span class="keyword">new</span> I(<span class="string"><span class="delimiter">'</span><span class="content">cleanup method</span><span class="delimiter">'</span></span>)
specInfo.addCleanupSpecInterceptor <span class="keyword">new</span> I(<span class="string"><span class="delimiter">'</span><span class="content">cleanup spec</span><span class="delimiter">'</span></span>)
specInfo.cleanupSpecMethods*.addInterceptor <span class="keyword">new</span> I(<span class="string"><span class="delimiter">'</span><span class="content">cleanup spec method</span><span class="delimiter">'</span></span>)
specInfo.allFixtureMethods*.addInterceptor <span class="keyword">new</span> I(<span class="string"><span class="delimiter">'</span><span class="content">fixture method</span><span class="delimiter">'</span></span>)</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_injecting_method_parameters"><a class="anchor" href="#_injecting_method_parameters"></a><a class="link" href="#_injecting_method_parameters">Injecting Method Parameters</a></h4>
<div class="paragraph">
<p>If your interceptor should support custom method parameters for wrapped methods, this can be done by modifying
<code>invocation.arguments</code>. Two use cases for this would be a mocking framework that can inject method parameters that are
annotated with a special annotation or some test helper that injects objects of a specific type that are created and
prepared for usage automatically.</p>
</div>
<div class="paragraph">
<p><code>invocation.arguments</code> may be an empty array or an array of arbitrary length, depending on what interceptors were run
before that maybe also have manipulated this array for parameter injection. So if you for example investigated the
method parameters with <code>invocation.method.reflection.parameters</code> and found that you want to inject the fifth parameter,
you should first check whether the <code>arguments</code> array is at least five elements long. If not, you should assign it a new
array that is at least five elements long and copy the contents of the old array into the new one. Then you can assign
your objects to be injected.</p>
</div>
<div class="listingblock">
<div class="title">Inject Method Parameters</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="comment">// create a map of all MyInjectable parameters with their parameter index</span>
<span class="predefined-type">Map</span>&lt;Parameter, <span class="predefined-type">Integer</span>&gt; parameters = [:]
invocation.method.reflection.parameters.eachWithIndex { parameter, i -&gt;
  parameters &lt;&lt; [(parameter): i]
}
parameters = parameters.findAll { MyInjectable.equals <span class="local-variable">it</span>.key.type }

<span class="comment">// enlarge arguments array if necessary</span>
<span class="keyword">def</span> lastMyInjectableParameterIndex = parameters*.value.max()
lastMyInjectableParameterIndex = lastMyInjectableParameterIndex == <span class="predefined-constant">null</span> ?
                                 <span class="integer">0</span> :
                                 lastMyInjectableParameterIndex + <span class="integer">1</span>
<span class="keyword">if</span>(invocation.arguments.length &lt; lastMyInjectableParameterIndex) {
  <span class="keyword">def</span> newArguments = <span class="keyword">new</span> <span class="predefined-type">Object</span>[lastMyInjectableParameterIndex]
  <span class="predefined-type">System</span>.arraycopy invocation.arguments, <span class="integer">0</span>, newArguments, <span class="integer">0</span>, invocation.arguments.length
  invocation.arguments = newArguments
}

parameters.each { parameter, i -&gt;
  invocation.arguments[i] = <span class="keyword">new</span> MyInjectable(parameter)
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>When using data driven features (methods with a <code>where:</code> block), the user of your extension has to follow some
restrictions, if parameters should be injected by your extension:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>all data variables and all to-be-injected parameters have to be defined as method parameters</p>
</li>
<li>
<p>all method parameters have to be assigned a value in the <code>where:</code> block</p>
</li>
<li>
<p>the order of the method parameters has to be identical to the order of the data variables in the <code>where:</code> block</p>
</li>
<li>
<p>the to-be-injected parameters have to be set to any value in the <code>where:</code> block, for example <code>null</code></p>
<div class="paragraph">
<p>of course you can also make your extension only inject a value if none is set already, as the <code>where:</code> block
assignments happen before the method interceptor is called</p>
</div>
<div class="paragraph">
<p>for this simply check whether <code>invocation.arguments[i]</code> is <code>null</code> or not</p>
</div>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Data Driven Feature with Injected Parameter</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy"><span class="keyword">def</span> <span class="string"><span class="delimiter">'</span><span class="content">test parameter injection</span><span class="delimiter">'</span></span>(a, b, MyInjectable myInjectable) {
  <span class="key">expect</span>: myInjectable

  <span class="key">where</span>:
  a    | b
  <span class="string"><span class="delimiter">'</span><span class="content">a1</span><span class="delimiter">'</span></span> | <span class="string"><span class="delimiter">'</span><span class="content">b1</span><span class="delimiter">'</span></span>
  <span class="string"><span class="delimiter">'</span><span class="content">a2</span><span class="delimiter">'</span></span> | <span class="string"><span class="delimiter">'</span><span class="content">b2</span><span class="delimiter">'</span></span>

  <span class="key">and</span>:
  myInjectable = <span class="predefined-constant">null</span>
}</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 1.2-SNAPSHOT<br>
Last updated 2018-09-09 02:12:07 UTC
</div>
</div>
</body>
</html>