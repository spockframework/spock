/*
 * Copyright 2012 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *     https://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.spockframework.idea

// only tested with 11.1, so play it safe and bail out on earlier version
if (!supportsVersion('11.1')) return

def ctx = context(ctype: 'spock.mock.MockingApi', scope: closureScope(isArg: true))

// Mock(Foo) { /* delegates to instance of type Foo */ }
// Foo x = Mock { /* delegates to instance of type Foo */ }
contributor(ctx) {
  def call = enclosingCall('Mock') ?: enclosingCall('Stub') ?: enclosingCall('Spy') ?:
      enclosingCall('GroovyMock') ?: enclosingCall('GroovyStub') ?: enclosingCall('GroovySpy')

  if (!call) return
  if (!respondsToParameterless(call, 'bind')) return

  def calledMethod = call.bind()

  if (!calledMethod) return
  if (!respondsToProperty(calledMethod, 'containingClass')) return

  def clazz = calledMethod.containingClass

  if (!clazz) return
  if (!respondsToProperty(clazz, 'qualName')) return
  if (clazz.qualName != 'spock.mock.MockingApi') return

  def delegateTo = { type ->
    if (respondsToProperty(type, 'boxedTypeName')) {
      delegatesTo(findClass(type.boxedTypeName))
    } else if (respondsToParameterless(type, 'resolve')) {
      delegatesTo(type.resolve())
    } else {
      delegatesTo(type)
    }
  }

  if (respondsToProperty(call, 'arguments')) {
    def explicitType = call.arguments.find {
      respondsToProperty(it, 'classType')
          && respondsToProperty(it.classType, 'name')
          && (it.classType.name == 'Class')
    }
    if (explicitType) {
      if (!respondsToProperty(explicitType, 'type')) return
      if (!respondsToProperty(explicitType.type, 'parameters')) return

      delegateTo(explicitType.type.parameters[0])
      return
    }
  }

  if (!respondsToProperty(call, 'context')) return

  def callContext = call.context
  if (respondsToProperty(callContext, 'typeGroovy')) {
    delegateTo(callContext.typeGroovy)
  } else if (respondsToProperty(callContext, 'LValue')) {
    delegateTo(callContext.LValue)
  }
}

List<MetaMethod> respondsToParameterless(Object target, String name) {
  return target.respondsTo(name, [] as Object[])
}

boolean respondsToProperty(target, String name) {
  def nameCapitalized = name.capitalize()
  return respondsToParameterless(target, "get$nameCapitalized")
      || respondsToParameterless(target, "is$nameCapitalized")*.returnType == [boolean]
      || target.hasProperty(name)
}

// From https://issues.apache.org/jira/browse/GROOVY-9510
// Properly resolve the delegatesTo for the closures of these extensions
def conditionalExtensions = ['spock.lang.Requires', 'spock.lang.IgnoreIf', 'spock.lang.PendingFeatureIf']
        .collect { annot -> context(ctype: "spock.lang.Specification", scope: closureScope(annotationName: annot))}
contributor(conditionalExtensions, {
    delegatesTo(findClass('org.spockframework.runtime.extension.builtin.PreconditionContext'))
})

contributor(context(ctype: "spock.lang.Specification", scope: closureScope(annotationName: 'spock.lang.Retry')), {
    delegatesTo(findClass('org.spockframework.runtime.extension.builtin.RetryConditionContext'))
})
